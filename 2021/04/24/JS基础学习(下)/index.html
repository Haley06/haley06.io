<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="事件事件对象 当事件的响应函数触发（用户执行了此事件）时，浏览器每次都会将一个事件对象作为**实参传入响应函数 **  在事件对象中封装了当前事件相关的一切信息，比如，鼠标坐标，哪个按键被按下，鼠标滚轮移动方向  事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行  由于浏览器要在事件执行的函数中传事件对象,所以事件的响应函数要有形参,一般设置为event  也可以在响应函数中使用**">
<meta property="og:type" content="article">
<meta property="og:title" content="JS基础学习（下）">
<meta property="og:url" content="http://haley06.com/2021/04/24/JS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%8B)/index.html">
<meta property="og:site_name" content="haley">
<meta property="og:description" content="事件事件对象 当事件的响应函数触发（用户执行了此事件）时，浏览器每次都会将一个事件对象作为**实参传入响应函数 **  在事件对象中封装了当前事件相关的一切信息，比如，鼠标坐标，哪个按键被按下，鼠标滚轮移动方向  事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行  由于浏览器要在事件执行的函数中传事件对象,所以事件的响应函数要有形参,一般设置为event  也可以在响应函数中使用**">
<meta property="og:locale">
<meta property="article:published_time" content="2021-04-23T19:35:09.000Z">
<meta property="article:modified_time" content="2021-04-24T07:42:07.441Z">
<meta property="article:author" content="haley06">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://haley06.com/2021/04/24/JS基础学习(下)/"/>





  <title>JS基础学习（下） | haley</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">haley</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haley06.com/2021/04/24/JS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%8B)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haley">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JS基础学习（下）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-24T03:35:09+08:00">
                2021-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul>
<li><p>当<strong>事件</strong>的<strong>响应函数触发（用户执行了此事件）</strong>时，<strong>浏览器</strong>每次都会<strong>将一个事件对象</strong>作为**实参传入响应函数 **</p>
</li>
<li><p>在<strong>事件对象中封装了当前事件相关的一切信息</strong>，比如，鼠标坐标，哪个按键被按下，鼠标滚轮移动方向</p>
</li>
<li><p>事件通常与<strong>函数</strong>配合使用，这样就可以通过发生的事件来驱动函数执行</p>
</li>
<li><p>由于浏览器要在事件执行的函数中传<strong>事件对象</strong>,所以事件的响应函数要有形参,一般设置为<strong>event</strong></p>
</li>
<li><p>也可以在响应函数中使用**arguments[0]**获取事件</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line"><span class="comment">//onmousemove事件会在鼠标移动时被触发</span></span><br><span class="line">box1.onmousemove=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event);<span class="comment">//MouseEvent &#123;isTrusted: true, screenX: 419, screenY: 191, clientX: 85, clientY: 88, …&#125;  是一个事件对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取鼠标位置</span></span><br><span class="line">    <span class="keyword">var</span> x=event.clientX;</span><br><span class="line">    <span class="keyword">var</span> y=event.clientY;</span><br><span class="line">    <span class="comment">// 在box2中显示（一般显示文字想innerHTML）鼠标坐标</span></span><br><span class="line">    box2.innerHTML=<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;,y=&quot;</span>+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h2><ul>
<li><p>浏览器事件</p>
</li>
<li><p>鼠标事件</p>
</li>
<li><p>键盘事件</p>
</li>
<li><p>表单事件</p>
</li>
<li><p>触摸事件</p>
<blockquote>
<p><code>onbort</code> 图像加载被中断</p>
<p><code>onblur</code>元素失去焦点</p>
<p><code>onchange</code>域的内容被改变</p>
<p><code>ondbclick</code>用户双击某个对象时</p>
<p><code>onclick</code>用户单击某个对象时</p>
<p><code>onerror</code>加载文档或者图像时发生错误</p>
<p><code>onfocus</code>元素获得焦点</p>
<p><code>onkeydown</code> 某个键盘按键按下时</p>
<p><code>onkeypress</code>某个按键按下并被松开时</p>
<p><code>onkeyup</code>某个键盘按键松开</p>
<p><code>onload</code>一张页面或一张图加载完成时</p>
<p><code>onmousedown</code>鼠标按钮按下</p>
<p><code>onmousemove</code>鼠标被移动</p>
<p><code>onmouseover</code>鼠标移到某元素上时</p>
<p><code>onmouseout</code>鼠标被移开时</p>
<p><code>onreset</code>重置按钮被点击时</p>
<p><code>onresize</code>窗口或框架大小被调整时</p>
<p><code>onselect</code>文本被选中</p>
<p><code>onsubmit</code>确认按钮被点击时</p>
<p><code>onunload</code>用户退出页面时</p>
<p><code>onwheel</code>鼠标滚轮滚动事件，会在滚轮滚动时触发</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上述事件都可以有单击响应函数,</span><br><span class="line">    !!!记得加event做参数才能通过event获取下方的属性!!!在函数中进行操作</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="鼠标-键盘属性"><a href="#鼠标-键盘属性" class="headerlink" title="鼠标/键盘属性"></a>鼠标/键盘属性</h2><ul>
<li><p><code>altKey</code>  返回当事件被触发时，”ALT” 是否被按下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.altKey=<span class="literal">true</span>|<span class="literal">false</span>|<span class="number">1</span>|<span class="number">0</span>  </span><br></pre></td></tr></table></figure></li>
<li><p><code>button</code>返回当事件被触发时，哪个鼠标按钮被点击</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.button=<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>鼠标左键</td>
</tr>
<tr>
<td>1</td>
<td>鼠标中键</td>
</tr>
<tr>
<td>2</td>
<td>鼠标右键</td>
</tr>
<tr>
<td>1<code>(ie)</code></td>
<td>鼠标左键</td>
</tr>
<tr>
<td>4<code>(ie)</code></td>
<td>鼠标中键</td>
</tr>
<tr>
<td>2<code>(ie)</code></td>
<td>鼠标右键</td>
</tr>
</tbody></table>
</li>
<li><p><code>clientX/Y</code>返回当事件被触发时，鼠标<strong>指针的水平/垂直坐标</strong></p>
</li>
<li><p><code>ctrlKey</code>返回当事件被触发时，<code>&quot;CTRL&quot;</code> 键是否被按下</p>
</li>
<li><p><code>relatedTarget</code>该属性返回与事件的目标节点相关的节点。</p>
<ul>
<li>对于 <code>mouseover</code> 事件来说，该属性是鼠标指针移到目标节点上时所离开的那个节点。</li>
<li>对于 <code>mouseout</code> 事件来说，该属性是离开目标时，鼠标指针进入的节点。</li>
<li>对于其他类型的事件来说，这个属性没有用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.relatedTarget.tagName</span><br></pre></td></tr></table></figure></li>
<li><p><code>screenX/Y</code>返回当事件被触发时，鼠标<strong>指针的水平/垂直坐标</strong></p>
</li>
<li><p><code>shiftKey</code>返回当事件被触发时，”SHIFT” 键是否被按下。</p>
</li>
<li><p><code>event.keyCode===40...</code>可以用于判断哪个具体键被按下,需要知道键盘编码</p>
</li>
<li><p>左上右下箭头键盘编码为37 38 39 40</p>
</li>
<li><p>其他属性: <a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/dom_obj_event.asp">https://www.w3school.com.cn/jsref/dom_obj_event.asp</a></p>
<ul>
<li>对于–X/Y使用区别见:  <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41342585/article/details/80659736">https://blog.csdn.net/weixin_41342585/article/details/80659736</a></li>
</ul>
</li>
</ul>
<p><strong>标准event属性,几乎event都有</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bubbles</td>
<td>返回布尔值，指示事件是否是起泡事件类型</td>
</tr>
<tr>
<td><code>cancelable</code></td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作</td>
</tr>
<tr>
<td><code>currentTarget</code></td>
<td>返回其事件监听器触发该事件的元素</td>
</tr>
<tr>
<td><code>eventPhase</code></td>
<td>返回事件传播的当前阶段。</td>
</tr>
<tr>
<td><strong><code>target</code></strong></td>
<td><strong>返回触发此事件的元素（事件的目标节点,节点有许多属性可以用(<code>className</code>..)）</strong></td>
</tr>
<tr>
<td><code>timeStamp</code></td>
<td>返回事件生成的日期和时间。</td>
</tr>
<tr>
<td><code>type</code></td>
<td>返回当前 Event 对象表示的事件的名称</td>
</tr>
</tbody></table>
<h2 id="事件的方法"><a href="#事件的方法" class="headerlink" title="事件的方法"></a>事件的方法</h2><ul>
<li><code>event.preventDefault()</code>可以取消默认行为</li>
<li><code>stopPropagation()</code>不再派发事件</li>
<li><code>initEvent</code>初始化新创建的 Event 对象的属性</li>
</ul>
<h2 id="事件的冒泡"><a href="#事件的冒泡" class="headerlink" title="事件的冒泡"></a>事件的冒泡</h2><ul>
<li><p>所谓的冒泡指的就是事件的向上传导，当后代元素事件被触发时，其他祖先元素相同事件也会被触发</p>
</li>
<li><p> 开发中冒泡很有用,如果不希望发生事件冒泡，可以通过事件对象取消冒泡</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 可以将事件对象的cancelBubble设置为true，即可取消冒泡</span></span><br><span class="line">event.cancelBubble=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="事件委派"><a href="#事件委派" class="headerlink" title="事件委派"></a>事件委派</h2><ul>
<li>事件的委派：将<strong>指定事件统一绑定给元素的祖先元素</strong>，这样当后代元素上的事件触发时，会一直冒泡到祖先元素    从而通过祖先元素的响应函数来处理事件</li>
<li>事件委派是利用了冒泡，通过委派可减少事件绑定次数，提高程序性能</li>
</ul>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul>
<li><p>问题</p>
<blockquote>
<ul>
<li>使用**对象.事件=函数 **的形式绑定响应函数,它只能同时为一个元素绑定的一个事件绑定一个单击响应函数，不能绑定多个响应函数</li>
<li>如果绑定多个，后边会覆盖前边的</li>
</ul>
</blockquote>
</li>
<li><p>解决使用**<code>addEventListener</code>**</p>
<blockquote>
<p><code>addEventListener()</code></p>
<p>​        -通过这个方法也可以<strong>为元素绑定单击响应函数</strong></p>
<p>​        -参数：</p>
<ul>
<li>1.事件的字符串，不要on</li>
<li>2.回调函数，当事件触发时该函数会被回调</li>
<li> 3.是否在捕获阶段触发事件，一般都传递false,不传也为false</li>
</ul>
<p>​        使用<code>addEventListener（）</code><strong>可以为一个元素的相同事件同时绑定多个响应函数</strong>, 这样事件被触发时，函数将会按照函数的绑定顺序执行</p>
<p>​        这个方法不支持<code>ie8</code>及以下浏览器</p>
<p>​            <code>attachEvent </code>代替<code>addEventListener</code>在：IE 7 8 下使用</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 		<span class="comment">//绑定会让第二个覆盖第一个最终只执行第二个</span></span><br><span class="line">		btn01.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">&quot;jsid&quot;</span>)</span><br><span class="line">            &#125; </span><br><span class="line">       <span class="comment">// 为btn01绑定第二个函数</span></span><br><span class="line">            btn01.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// alert(&quot;jsyfyfud&quot;)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下边两个会依次执行,所以以后用addEventListener()</span></span><br><span class="line"> btn01.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               alert(<span class="number">1</span>);</span><br><span class="line">           &#125;,<span class="literal">false</span>);</span><br><span class="line">           btn01.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               alert(<span class="built_in">this</span>);<span class="comment">//this是绑定事件的对象</span></span><br><span class="line">           &#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><ul>
<li><p>关于<strong>事件传播</strong>网景和微软理解不同</p>
<ul>
<li><strong>微软</strong>：由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后向当前元素的祖先元素上传播,即<strong>事件的冒泡</strong></li>
<li> <strong>网景</strong>公司：认为由外向内传播，为<strong>事件捕获阶段</strong></li>
</ul>
</li>
<li><p><code>w3c</code>综合两个方案：将事件传播分为3个阶段：</p>
<ul>
<li><strong>事件捕获</strong>：由祖先（document）（大部分浏览器为window）向目标元素进行事件捕获，但是默认不会触发</li>
<li><strong>目标</strong>阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件</li>
<li><strong>冒泡</strong>阶段：事件从目标元素上向他的祖先元素传递，依次触发事件</li>
</ul>
</li>
</ul>
<p>​        <strong>如果希望捕获阶段就执行，可将<code>addEventListener()</code>第三个参数设置为true，一般情况不使用，用true，</strong></p>
<ul>
<li><em><code> ie8</code>不会捕获，只有冒泡</em></li>
</ul>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a><code>BOM</code>对象</h2><ul>
<li><p><code>BOM</code>是浏览器对象 </p>
</li>
<li><p><code>BOM</code>可以使我们通过<code>js</code>操作浏览器(不是操作网页)</p>
</li>
<li><p>在<code>BOM</code>中为我们提供一组对象,用来完成浏览器操作</p>
<ul>
<li><blockquote>
<p> Window</p>
<p>​            -代表整个浏览器窗口,同时window也是网页全局对象</p>
</blockquote>
</li>
<li><blockquote>
<p>Navigator</p>
<p>​            –代表当前浏览器信息,通过该对象可识别不同浏览器</p>
</blockquote>
</li>
<li><blockquote>
<p>Location</p>
<p>​            –代表当前浏览器的地址栏信息,通过location可以获取地址栏信息,或者操作浏览器跳转页面</p>
</blockquote>
</li>
<li><blockquote>
<p> History</p>
<p>​            –代表浏览器历史记录,可通过该对象来操作浏览器历史记录</p>
<p>​              由于隐私原因,该对象不能获取具体历史记录,只能操作浏览器前进或后退</p>
<p>​              而且该操作只在当此访问时间有效</p>
</blockquote>
</li>
<li><blockquote>
<p>Screen</p>
<p>​            –代表用户屏幕信息,通过该对象可获取用户显示器相关信息</p>
</blockquote>
</li>
</ul>
</li>
<li><p>这些<code>BOM</code>对象在<code>window</code>中都是作为<code>window</code>对象属性保存的,可以通过<code>window</code>对象来使用,也可<strong>直接使用</strong></p>
</li>
</ul>
<h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*navigator</span></span><br><span class="line"><span class="comment">--代表当前浏览器信息,通过该对象可识别不同浏览器 ,由于历史原因,Navigator对象中大部分属性已经不能帮助我们识别浏览器</span></span><br><span class="line"><span class="comment"> --一般使用userAgent判断浏览器的信息,userAgent是字符串,这个字符串包含用来指浏览器信息的内容,不同浏览器有不同的userAgent*/</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(navigator.appName);<span class="comment">//Netscape</span></span><br><span class="line">              <span class="built_in">console</span>.log(navigator.userAgent);</span><br><span class="line">              <span class="comment">/* Chrome:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36</span></span><br><span class="line"><span class="comment">Navigator.html:45  */</span></span><br></pre></td></tr></table></figure>

<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">属性:</span></span><br><span class="line"><span class="comment">	-length属性:可以用来获取到当前链接访问的数量</span></span><br><span class="line"><span class="comment">方法:</span></span><br><span class="line"><span class="comment">	historyback()  可以用来回退到上一页个页面,和浏览器回退按钮一样 </span></span><br><span class="line"><span class="comment">	history.forward()  可以跳转到下一个页面,与浏览器前进相同</span></span><br><span class="line"><span class="comment">	history.go()</span></span><br><span class="line"><span class="comment">		go()可以用来跳转到指定的页面,它需要一个整数参数</span></span><br><span class="line"><span class="comment">        1表示向前跳转一个页面,2表示向前跳转两个页面,</span></span><br><span class="line"><span class="comment">        -1表示向后跳转一个页面,-2表示向后跳转两个页面</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	location中封装了地址栏的信息</span></span><br><span class="line"><span class="comment">	-直接打印location可获取地址栏信息（当前页面完整路径）</span></span><br><span class="line"><span class="comment">	-直接将location属性修改为一个完整路径，或相对路径，则页面会自动跳转到该路径,生成相应历史记录</span></span><br><span class="line"><span class="comment">	方法:</span></span><br><span class="line"><span class="comment">	-location.assign()用于跳转到其他页面，和location一样，会生成历史记录</span></span><br><span class="line"><span class="comment">	- location.reload():用于重新加载当前页面</span></span><br><span class="line"><span class="comment">   如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面</span></span><br><span class="line"><span class="comment">   	- location.replace()会使用一个新页面替换当前页面，调用完毕也会跳转页面,不会生成历史记录，不能使用回退按钮回退</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	location=<span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log(location);</span><br><span class="line"></span><br><span class="line">	location.assign(<span class="string">&quot;http:www.baidu.com&quot;</span>);</span><br><span class="line">	location.reload(<span class="literal">true</span>);</span><br><span class="line">	location.replace(<span class="string">&quot;test02.html&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><strong><code>setInterval()</code></strong>   定时调用</p>
<p><strong>到时间只执行一次</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	-定时调用</span></span><br><span class="line"><span class="comment">    -可以将一个函数，每隔一段时间执行一次</span></span><br><span class="line"><span class="comment">    -参数：1.回调函数：该函数会每隔一段时间被调用一次</span></span><br><span class="line"><span class="comment">          2.每次调用间隔的时间，单位是ms(1000ms=1s)</span></span><br><span class="line"><span class="comment">     -返回值：返回一个NUmber类型数据</span></span><br><span class="line"><span class="comment">clearInterval()</span></span><br><span class="line"><span class="comment">      -可用来关闭一个定时器,方法中需要一个定时器标识作为参数,这样将关闭标识对应的计时器</span></span><br><span class="line"><span class="comment">		clearInterval(timer)</span></span><br><span class="line"><span class="comment">		-如果参数是一个有效的定时器标识符,则停止对应定时器</span></span><br><span class="line"><span class="comment">        -如果参数不是一个有效标识,则什么也不做</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count=<span class="built_in">document</span>.getElementById(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> num=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> timer=<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">//    每隔1snum自增，并将其赋值给count.innerhtml（h1内容）</span></span><br><span class="line">               count.innerHTML=num++;</span><br><span class="line">               <span class="keyword">if</span>(num==<span class="number">11</span>)&#123;</span><br><span class="line">                   <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">               &#125;</span><br><span class="line">  &#125;,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong><code>setTImeout() </code></strong> 延时调用</p>
<p><strong>到时间会自动执行多次</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 延时调用</span></span><br><span class="line"><span class="comment">     指一个函数不马上执行，隔一段时间后才执行,而且只执行一次</span></span><br><span class="line"><span class="comment">      延时调用和定时调用区别：定时调用执行多次，延时调用执行一次</span></span><br><span class="line"><span class="comment">      二者可以相互替代，在开发中可以根据自己需要选择，定时调用多用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">           <span class="keyword">var</span> num=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">var</span> timer=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(num++);</span><br><span class="line">           &#125;,<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//    关闭延时调用</span></span><br><span class="line">           <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<ul>
<li><code>js</code>中的对象只有<code>js</code>认识，其他语言都不认识</li>
<li><code>JSON</code>是一个<strong>特殊格式字符串</strong>，这个字符串可以被任意语言识别，并且可以转为任意语言对象</li>
<li>   <code>JSON</code>主要用来<strong>数据交互</strong>在开发中</li>
<li><code>JSON</code>与<code>js</code>对象格式一样，只不过<code>JSON</code>字符串中的属性名必须加双引号,其他和<code>js</code>语法一样</li>
</ul>
</blockquote>
<h3 id="其他JSON知识"><a href="#其他JSON知识" class="headerlink" title="其他JSON知识"></a>其他JSON知识</h3><ul>
<li><p>分类</p>
<ul>
<li>对象 {}</li>
<li>[]</li>
</ul>
</li>
<li><p>允许的值:</p>
</li>
<li><p>字符串、数值、布尔值、null、对象、数组</p>
</li>
<li><p><code>JS</code>与<code>JSON</code>转化</p>
<p><strong>在<code>js</code>中，为我们提供了工具类，叫<code>JSON</code>,这个对象可以帮助我们将<code>JSON</code>转换为<code>JS</code>对象，也可以将<code>js</code>转为<code>JSON</code></strong></p>
<ul>
<li><p><code>JSON</code>-&gt;<code>JS</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json=<span class="string">&#x27;&#123;&quot;name&quot;:&quot;haley&quot;,&quot;age&quot;:18&#125;&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> arr=<span class="string">&#x27;[1,2,3,&quot;hello&quot;,true,&#123;&quot;name&quot;:&quot;haley&quot;,&quot;age&quot;:18&#125;]&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">      json--》js对象：</span></span><br><span class="line"><span class="comment">          -JSON.parse() 可以将以JSON字符串转为js对象</span></span><br><span class="line"><span class="comment">          -它需要一个JSON字符串作为参数，会将该字符串转为JS对象并返回</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  <span class="keyword">var</span> o=<span class="built_in">JSON</span>.parse(json);</span><br><span class="line">  <span class="built_in">console</span>.log(o);<span class="comment">//&#123;name: &quot;haley&quot;, age: 18&#125;</span></span><br><span class="line">  <span class="keyword">var</span> o2=<span class="built_in">JSON</span>.parse(arr);</span><br><span class="line">  <span class="built_in">console</span>.log(o2);<span class="comment">//[1, 2, 3, &quot;hello&quot;, true, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>JS</code>-&gt;<code>JSON</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	JSON.Stringify()</span></span><br><span class="line"><span class="comment">            -可以将一个js对象转换为JSON字符串</span></span><br><span class="line"><span class="comment">            -需要一个js对象作为参数，会返回JSON字符串</span></span><br><span class="line"><span class="comment">*/</span>		</span><br><span class="line">		<span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&#x27;haley&#x27;</span>,<span class="attr">age</span>:<span class="number">28</span>,<span class="attr">gender</span>:<span class="string">&#x27;nv&#x27;</span>&#125;</span><br><span class="line"> 		<span class="keyword">var</span> str=<span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">        <span class="built_in">console</span>.log(str);<span class="comment">//&#123;&quot;name&quot;:&quot;haley&quot;,&quot;age&quot;:28,&quot;gender&quot;:&quot;nv&quot;&#125;</span></span><br><span class="line">        <span class="keyword">var</span> str1=<span class="string">&#x27;&#123;&quot;name&quot;:&quot;haley&quot;,&quot;age&quot;:28,&quot;gender&quot;:&quot;nv&quot;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>其他知识</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eval():</span></span><br><span class="line"><span class="comment">            -这个函数可以用来执行一段字符串形式的js代码，并将执行结果返回</span></span><br><span class="line"><span class="comment">            -如果使用eval（）执行的字符串中含有&#123;&#125;，它会将&#123;&#125;当成代码块</span></span><br><span class="line"><span class="comment">                如果不希望将其作为代码块解析，则需要在字符串前后各加一个（）</span></span><br><span class="line"><span class="comment">            -eval()功能很强大，可以直接执行一个字符串中js代码，但在开发中尽量不要使用</span></span><br><span class="line"><span class="comment">            首先，其执行性能差，还有安全隐患</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="keyword">var</span> str3=<span class="string">&quot;alert(&#x27;hello&#x27;);&quot;</span></span><br><span class="line">      <span class="keyword">var</span> obj=<span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span>+str3+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="高级JS"><a href="#高级JS" class="headerlink" title="高级JS"></a>高级<code>JS</code></h1><ul>
<li>这是简单的深入了一下学习<code>JS</code></li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p><strong>数据类型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数据类型:<span class="number">8</span>种</span><br><span class="line">基本数据类型:	<span class="built_in">Number</span>,string,<span class="built_in">BigInt</span>,<span class="built_in">Boolean</span>,Undefined,Null,<span class="built_in">Symbol</span></span><br><span class="line">引用数据类型: <span class="built_in">Object</span>(<span class="built_in">Function</span>,<span class="built_in">Array</span>)</span><br><span class="line"></span><br><span class="line">基本:</span><br><span class="line">string:任意字符串	<span class="built_in">Number</span>:任意数字   <span class="built_in">Boolean</span>:<span class="literal">true</span>/<span class="literal">false</span>	Undefined:<span class="literal">undefined</span> Null:<span class="literal">null</span></span><br><span class="line">引用(对象)类型:</span><br><span class="line"><span class="built_in">Object</span> 任意对象		<span class="built_in">Function</span> 一种特别对象(可执行)</span><br><span class="line"><span class="built_in">Array</span>:一种特别对象 (数值下标,内部数据是有序的)</span><br></pre></td></tr></table></figure>

<p><strong>判断</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">typeof</span> 返回数据类型字符串表示</span><br><span class="line">        <span class="keyword">instanceof</span></span><br><span class="line">        ===/==（会数据转换）</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;undefined&quot;</span>==<span class="literal">undefined</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>==<span class="number">0</span>)<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>==<span class="literal">undefined</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>问题</strong></p>
<ul>
<li><p>undefined与null的区别?</p>
<p><strong>undefined</strong></p>
<ul>
<li><p>字面上,未定义的值;</p>
<p>语义:表示一个变量最原始的状态,非人为操作结果</p>
</li>
<li><p>4种场景常见</p>
<ul>
<li><p>声明一个变量,没有赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//undefined 表示该变量没有使用过自声明以来,也没有定义过任何有效值</span></span><br></pre></td></tr></table></figure></li>
<li><p>访问对象上不存在属性或未定义的变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.foo)<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> deml)<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数定义了形参,没有传实参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></li>
<li><p>使用void表达式求值和当函数没有返回值或返回return;时的返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">void</span> [];</span><br><span class="line"><span class="keyword">void</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">结果均为<span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>ES规定void操作符对任何表达式求值都返回undefined,这和函数执行操作后没有返回值作用一样.</p>
</li>
</ul>
</li>
</ul>
<p><strong>null</strong></p>
<ul>
<li>字面上:空值。</li>
<li>希望一个对象被人为重置为空对象,而非一个变量最原始状态</li>
<li>在内存里表示的是**:栈中的变量没有指向堆中的内存对象**</li>
<li>一般以下两种情况会变量赋值为null<ul>
<li>定义的变量将来用于保存对象,初始化为null,利于区分null和undefined</li>
<li>当一个数据不再使用时,最好通过将其设置为null来释放其引用,叫做<strong>解除引用。</strong>解除引用以便垃圾收集器下次运行时将其回收。</li>
<li><code>typeof null</code> 结果为<code>object</code></li>
</ul>
</li>
</ul>
</li>
<li><p>严格区别变量类型与数据类型？</p>
<p>​       数据类型：基本类型</p>
<p>​                            对象类型</p>
<p>​       变量类型：（变量内存值的类型）</p>
<p>​            基本类型：保存的是基本类型数据</p>
<p>​            引用类型：保存的地址值</p>
</li>
</ul>
<h3 id="数据-变量-内存"><a href="#数据-变量-内存" class="headerlink" title="数据,变量,内存"></a>数据,变量,内存</h3><ul>
<li><p>什么是数据?</p>
<blockquote>
<ul>
<li>存储在内存中代表特定信息的东东，本质是0101.。。</li>
<li>数据的特点：可传递，可运算</li>
<li>一切皆数据</li>
<li> 内存中所以操作的目标：数据</li>
<li>算术运算，逻辑运算，赋值运算，运行函数</li>
</ul>
</blockquote>
</li>
<li><p>什么是内存?</p>
<blockquote>
<ul>
<li><p>内存空间是临时的，硬盘空间是持久的</p>
</li>
<li><p>内存条通电后产生的可存储数据的空间（临时的）</p>
</li>
<li><p> 内存产生和死亡：内存条（电路板）<code>==》</code>通电<code>==》</code>产生内存空间<code>==》</code>存储数据<code>==》</code>处理数据<code>==》</code>断电==》内存空间和数据都消失</p>
</li>
<li><p> 一块小内存包含2个数据</p>
</li>
<li><p>内部存储的数据（一般数据/地址数据）</p>
</li>
<li><p>地址值</p>
</li>
<li><p>内存分类：</p>
<ul>
<li>栈:全局变量/局部变量 标识函数函数名在栈空间 空间较小</li>
<li>堆：对象（函数）</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>什么是变量?</p>
<blockquote>
<ul>
<li>可变化的量：由变量名和变量值组成，</li>
<li>每个变量都对应一块小内存，变量名（内存标识）用来查找对应内存，变量值就是内存中保存的数据</li>
</ul>
</blockquote>
</li>
<li><p>内存，数据，变量的关系</p>
<p><strong>内存</strong>是用来<strong>存储数据</strong>的<strong>空间</strong>，<strong>变量</strong>是内存的<strong>标识</strong>，通过变量找到对应内存进而<strong>操作（读/写）数据</strong></p>
</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li><p>1.<code>var a=xxx,</code>a内存中到底保存的是什么？</p>
<blockquote>
<p>​     <code>xxx</code>是基本数据，保存的就是这个数据</p>
<p>​     <code>xxx</code>是对象，保存的是对象地址值</p>
<p>​     <code>xxx</code>是一个变量,保存的是<code>xxx</code>的内存的内容（可能是基本数据，也可能是地址值）</p>
</blockquote>
</li>
<li><p>2.关于引用变量赋值问题</p>
<blockquote>
<ul>
<li>n个引用变量指向同一个对象，通过一个变量修改对象内部数据，其他所有变量看到的是修改之后的数据</li>
<li>2个引用变量指向同一个对象,让其中一个引用变量指向另一个对象，另一引用变量依然指向前一个对象</li>
</ul>
</blockquote>
</li>
<li><p>3.在<code>js</code>调用函数时传递变量参数时，是值传递还是引用传递？</p>
<blockquote>
<p>​        理解一：值传递（基本/地址值）</p>
<p>​        理解二：可能是值传递，也可能是引用传递（地址值）</p>
</blockquote>
</li>
<li><p>4.<code>js</code>引擎如何管理内存？</p>
<blockquote>
<p>  1.内存生命周期</p>
<ul>
<li>分配小内存空间，得到它的使用权</li>
<li>存储数据，可以反复进行操作、</li>
<li>释放小内存空间</li>
</ul>
<p>2.释放内存  </p>
<p>​        局部变量：函数执行完自动释放</p>
<p>​        对象：成为垃圾对象==》垃圾回收器回收</p>
</blockquote>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>什么是函数?</p>
<blockquote>
<p>​     实现特定功能的n条<strong>语句的封装体</strong></p>
<p>​      <strong>只有函数是可以执行的，其他类型数据不能执行</strong></p>
</blockquote>
</li>
<li><p>为什么要调用函数?</p>
<ul>
<li>提高代码复用,便于阅读交流</li>
</ul>
</li>
<li><p>如何定义函数?</p>
<ul>
<li>函数声明</li>
<li>表达式</li>
</ul>
</li>
<li><p>如何调用执行函数</p>
<ul>
<li><p><code>test()</code>直接调用</p>
</li>
<li><p><code>obj.tets()</code>通过对象调用</p>
</li>
<li><p><code>new test()</code>new 调用</p>
</li>
<li><p><code>test.call/apply(obj,参数)</code></p>
<p>修改test函数的this调用</p>
</li>
</ul>
</li>
</ul>
<p><strong>回调函数</strong></p>
<ul>
<li><p>什么是回调函数?</p>
<blockquote>
<p>​     1.你定义的</p>
<p>​      2.你没有调</p>
<p>​      3.但最终它执行了</p>
</blockquote>
</li>
<li><p>常见的回调函数</p>
<blockquote>
<p>​     1.定时器回调函数</p>
<p>​      2.<code>dom</code>事件回调函数(<code>addEventListener(&#39;click&#39;,function()&#123;&#125;,false)</code>)</p>
<p>​      3.<code>ajax</code>请求回调函数 与后端交互</p>
<p>​      4.<code>vue</code>生命周期回调函数</p>
</blockquote>
</li>
</ul>
<p><strong><code>IIFE</code></strong></p>
<ul>
<li><p>全称：<code>Innediately-INvoked Function Expression</code> 匿名函数自调用</p>
</li>
<li><p>作用</p>
<ul>
<li><p>隐藏实现</p>
</li>
<li><p>不会污染全局作用域</p>
</li>
<li><p>用它可以编写<code>JS</code>模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">         <span class="built_in">console</span>.log(++a); </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">       <span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="comment">//向外暴露一个全局函数</span></span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">           test: test,</span><br><span class="line">         &#125;;</span><br><span class="line">       &#125;;</span><br><span class="line">     &#125;)();<span class="comment">//这里调用了一遍 </span></span><br><span class="line">     <span class="comment">//下边调用里边test函数又一遍</span></span><br><span class="line">     $().test(); <span class="comment">//2  $是一个函数名，$执行后返回的是一个对象，对象里有个test方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>加分号问题</p>
<blockquote>
<p>1.<code>js</code>一条语句后面可以不加分号</p>
<p>2.是否加分号是编码风格问题，没有应不应该，只有喜不喜欢</p>
<p>3.下面2种情况下不加分号会有问题</p>
<pre><code>   小括号开头的前一条语句
   
   中方括号开头的前一条语句
</code></pre>
<p>4.解决办法：在行首加分号</p>
<p>5.强有力例子：<code>vue.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> a = <span class="number">3</span>   <span class="comment">//应该加;</span></span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)();</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">错误理解：</span></span><br><span class="line"><span class="comment"> var a=3(function()&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        &#125;)()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      <span class="keyword">var</span> b = <span class="number">4</span><span class="comment">//应该加;</span></span><br><span class="line">      [<span class="number">1</span>, <span class="number">3</span>].forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">错误理解： var b=4[1,3].forEach(element =&gt; &#123;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br></pre></td></tr></table></figure>

<p>形参的本质是变量</p>
</blockquote>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote>
<pre><code> 1.作用域：一块地盘，一个代码所在区域
</code></pre>
<p>​                        它是静态的（相当于上下文对象），在编写代码时就确定了</p>
<p>​    2.分类：全局作用域</p>
<p>​                    函数作用域</p>
<p>​                    块级作用域（<code>Es6</code>有了）</p>
<p>​    3.作用：</p>
<p>​                  隔离变量，不同作用域下同名变量不会有冲突</p>
</blockquote>
<p><strong>总结</strong></p>
<blockquote>
<ul>
<li><p>找变量<code>（a）</code>沿着作用域链找，找属性<code>（a.b）</code>找原型链</p>
</li>
<li><p>作用域：代码块区域</p>
<ul>
<li>个数：n+1个（n为代码块数）</li>
<li>作用：隔离变量</li>
<li>作用域链：嵌套函数，先看当前作用域再看出一层作用域有没有，如果找完还没有，就报错</li>
<li>作用：查找变量</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>执行上下文与作用域区别</strong>：</p>
<ul>
<li><p>全局作用域之外每个函数都会创建自己的作用域，作用域在函数定义时就已经确定，不是在函数调用时</p>
</li>
<li><p>全局执行上下文在全局作用域确定后，<code>js</code>代码马上执行之前创建</p>
<p>函数执行上下文在调用函数时，函数体代码执行前创建</p>
</li>
</ul>
<ul>
<li>作用域是静态的，只要函数定义好就一直存在，不会在改变</li>
<li>上下文是环境动态的，调用函数时创建，函数调用结束时上下文环境会被释放</li>
</ul>
<p><strong>联系</strong>：</p>
<p>​    上下文环境（对象）是从属于所在作用域</p>
<p>​    全局上下文环境==》全局作用域</p>
<p>​    函数上下文环境==》对应函数作用域 </p>
<p><strong>练习</strong></p>
<ul>
<li>练习1</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(x);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">   f();</span><br><span class="line"> &#125;</span><br><span class="line"> show(fn); <span class="comment">//10  fn作用域和show作用域是并列的，他们自己作用域没有变量就直接向全局作用域找</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> 题2 */</span></span><br><span class="line"> <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(fn);</span><br><span class="line"> &#125;;</span><br><span class="line"> fn();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">   fn2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// console.log(fn2);//error 此时函数作用域中没有fn2,就直接去全局中找，不在对象中找，而全局没有，所以报错</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.fn2); <span class="comment">//这样才会输出obj的fn2</span></span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;;</span><br><span class="line"> obj.fn2();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>练习2</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">c=<span class="number">3</span><span class="comment">//window里有c</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">window</span>.c);<span class="comment">//3</span></span><br><span class="line">       <span class="comment">//  全局执行上下文 找变量从window中找</span></span><br><span class="line">        <span class="built_in">console</span>.log(a1,<span class="built_in">window</span>.a1);<span class="comment">//undefined undefined</span></span><br><span class="line">       a2();<span class="comment">//jkfld</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">        <span class="keyword">var</span> a1=<span class="number">3</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">a2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;jkfld&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;----------------&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//  函数执行上下文  执行才会创建堆空间</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a1</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(a1);<span class="comment">//2</span></span><br><span class="line">           <span class="built_in">console</span>.log(a2);<span class="comment">//undefined</span></span><br><span class="line">           a3();<span class="comment">//fun()</span></span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);<span class="comment">//2,3  伪数组（2，3）</span></span><br><span class="line">           <span class="keyword">var</span> a2=<span class="number">3</span>;</span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">a3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;fun()&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       fn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">       <span class="comment">// 局部变量在栈里</span></span><br></pre></td></tr></table></figure>

<p><strong>练习3(典型)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">      测试题3</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//   c(2); //error</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> c); <span class="comment">//number</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> c; <span class="comment">//变量声明提升！！！！不是赋值</span></span><br><span class="line">    <span class="comment">// 函数提升优先级高于变量提升优先级，函数提升的晚</span></span><br><span class="line">    <span class="comment">// 此处变量c先声明未赋值，之后函数提升，最后才是c赋值，所以为number</span></span><br><span class="line">    <span class="comment">// 若c没有赋值，则c为function，function会覆盖undefined（测试题一就是这样）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(c);</span><br><span class="line">    &#125;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">    c(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>执行上下文栈</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.在全局代码执行前，js引擎会创建一个栈来存储管理所有执行上下文的对象</span></span><br><span class="line"><span class="comment">      2.在全局执行上下文（window）确定后，将其添加到栈中（压栈）</span></span><br><span class="line"><span class="comment">      3.在函数执行上下文创建后，将其添加到栈中（压栈）</span></span><br><span class="line"><span class="comment">      4.在当前函数执行完后，将栈顶对象移除（出栈）</span></span><br><span class="line"><span class="comment">      5.当所有代码执行完后，栈中只剩下window*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><strong>五种方式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">        Object构造函数模式</span></span><br><span class="line"><span class="comment">        套路：先创建空Object对象，再动态添加属性和方法</span></span><br><span class="line"><span class="comment">        使用场景：起始时不确定对象内部数据,之后重新赋值</span></span><br><span class="line"><span class="comment">        问题：语句太多</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">/* 创建一个人 */</span></span><br><span class="line">       <span class="keyword">var</span> p=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">       p.name=<span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">       p.age=<span class="number">12</span></span><br><span class="line">       p.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name=name;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//    测试</span></span><br><span class="line">    p.setName(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(p.name);<span class="comment">//John</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    方法二：对象字面量模式</span></span><br><span class="line"><span class="comment">    套路：使用&#123;&#125;创建对象，同时指定属性/方法</span></span><br><span class="line"><span class="comment">    使用场景：起始时对象内部数据是确定的</span></span><br><span class="line"><span class="comment">    问题：如果创建多个对象有代码重复问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">var</span> p1=&#123;</span><br><span class="line">       name:<span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">       age:<span class="number">12</span>,</span><br><span class="line">       setName:<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name=name;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//    测试</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name,p1.age);</span><br><span class="line">p1.setName(<span class="string">&#x27;hjkhk&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.name,p1.age);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">方法3：工厂模式</span></span><br><span class="line"><span class="comment">   套路：通过工厂模式动态创建对象并返回</span></span><br><span class="line"><span class="comment">   使用场景：创建多个对象</span></span><br><span class="line"><span class="comment">   问题：对象没有一个具体类型(都是人，不知道是老师，学生，还是父母。。。)，都是Object类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">creatPerson</span>(<span class="params">name,age</span>)</span>&#123;<span class="comment">//返回一个对象的函数可称为工厂函数</span></span><br><span class="line">       <span class="keyword">var</span> obj=&#123;</span><br><span class="line">           name:name,</span><br><span class="line">           age:age,</span><br><span class="line">           setName:<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">               <span class="built_in">this</span>.name=name;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> obj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> p3=creatPerson(<span class="string">&#x27;ghjg&#x27;</span>,<span class="number">15</span>);</span><br><span class="line">   <span class="keyword">var</span> p4=creatPerson(<span class="string">&#x27;ghjg&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(p3 <span class="keyword">instanceof</span> creatPerson);<span class="comment">//false</span></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">   方法四：</span></span><br><span class="line"><span class="comment">   自定义构造函数模式：</span></span><br><span class="line"><span class="comment">    套路：自定义构造函数，通过new创建对象</span></span><br><span class="line"><span class="comment">    使用场景：需要创建多个类型确定的对象</span></span><br><span class="line"><span class="comment">    问题：每个对象都有相同数据，浪费内存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person1</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name=name;</span><br><span class="line">      <span class="built_in">this</span>.age=age;</span><br><span class="line">      <span class="built_in">this</span>.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.name=name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//不用return</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> p5=<span class="keyword">new</span> Person1(<span class="string">&#x27;Tom0&#x27;</span>,<span class="number">15</span>);</span><br><span class="line">  p5.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(p5.name,p5.age);</span><br><span class="line">  <span class="built_in">console</span>.log(p5 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,address</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name=name;</span><br><span class="line">      <span class="built_in">this</span>.address=address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> s=<span class="keyword">new</span> Student(<span class="string">&#x27;haley&#x27;</span>,<span class="number">16</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Student);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> p6=<span class="keyword">new</span> Person1(<span class="string">&#x27;sdfas&#x27;</span>,<span class="number">15</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(p5,p6);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  方法五：</span></span><br><span class="line"><span class="comment">    构造函数+原型组合模式</span></span><br><span class="line"><span class="comment">    套路：自定义构造函数，属性在函数中初始化，方法添加到原型上</span></span><br><span class="line"><span class="comment">    使用场景：需要创建多个类型确定的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name=name;</span><br><span class="line">      <span class="built_in">this</span>.age=age;</span><br><span class="line">      &#125;</span><br><span class="line">      Person.prototype.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.name=name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> p7=<span class="keyword">new</span> Person(<span class="string">&#x27;haleuy&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">      <span class="keyword">var</span> p8=<span class="keyword">new</span> Person(<span class="string">&#x27;hauy&#x27;</span>,<span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(p7,p8);</span><br></pre></td></tr></table></figure>

<p><strong>原型链继承</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">        原型链继承：</span></span><br><span class="line"><span class="comment">        1.套路：</span></span><br><span class="line"><span class="comment">            1.定义父类型构造函数</span></span><br><span class="line"><span class="comment">            2.给父类型原型添加方法</span></span><br><span class="line"><span class="comment">            3.定义子类型构造函数</span></span><br><span class="line"><span class="comment">            4.创建父类型对象赋值给子类型的原型</span></span><br><span class="line"><span class="comment">            5.将子类型原型的构造属性设置为子类型//constructor</span></span><br><span class="line"><span class="comment">            6.给子类型原型添加方法</span></span><br><span class="line"><span class="comment">            7.创建子类型对象：可以调用父类型方法</span></span><br><span class="line"><span class="comment">        2.关键：</span></span><br><span class="line"><span class="comment">            子类型的原型为父类型的一个实例对象</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//  父类型</span></span><br><span class="line">         <span class="function"><span class="keyword">function</span> <span class="title">Supper</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">this</span>.supSuper=<span class="string">&#x27;Supper property&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Supper.prototype.showSupperProp=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="built_in">this</span>.supSuper);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//  子类型</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.Subprop=<span class="string">&#x27;Sub property&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子类型的原型为父类型的一个实例对象  想看到Super方法就找Super实例</span></span><br><span class="line">        Sub.prototype=<span class="keyword">new</span> Supper();</span><br><span class="line">        <span class="comment">// 让子类型的原型constructor指向子类型</span></span><br><span class="line">        Sub.prototype.constructor=Sub;</span><br><span class="line">        Sub.prototype.showSubprop=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//谁调用此方法将来谁就是this</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.Subprop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sub=<span class="keyword">new</span> Sub();</span><br><span class="line">        <span class="comment">// sub.showSupperProp();  error</span></span><br><span class="line">        sub.toString();<span class="comment">//toString()在Object上</span></span><br><span class="line">        sub.showSupperProp();<span class="comment">//加了38行不报错</span></span><br><span class="line">        sub.showSubprop();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(sub.constructor);<span class="comment">//查看Sub构造函数  此时指向Supper（）</span></span><br><span class="line">        <span class="built_in">console</span>.log(sub.constructor);<span class="comment">//添加38行后查看Sub构造函数  此时指向Sub（）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        方式2： 借用构造函数继承（假的）</span></span><br><span class="line"><span class="comment">            1.套路：</span></span><br><span class="line"><span class="comment">                1.定义父类型构造函数</span></span><br><span class="line"><span class="comment">                2.定义子类型构造函数</span></span><br><span class="line"><span class="comment">                3.在子类型构造函数中调用父类型构造函数</span></span><br><span class="line"><span class="comment">            2.关键：</span></span><br><span class="line"><span class="comment">                1.在子类型构造函数中用Call（）调用父类型构造函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name=name;</span><br><span class="line">            <span class="built_in">this</span>.age=age;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,price</span>)</span>&#123;</span><br><span class="line">           Person.call(<span class="built_in">this</span>,name,age);<span class="comment">//相当于：this.Person（name，age） 为了得到父类型方法</span></span><br><span class="line">            <span class="comment">//  this是new出的s，s为子类型实例</span></span><br><span class="line">           <span class="built_in">this</span>.price=price;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> s=<span class="keyword">new</span> Student(<span class="string">&#x27;TOm&#x27;</span>,<span class="number">16.14000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">       方式3：原型链+使用构造函数的组合要求</span></span><br><span class="line"><span class="comment">       1.利用原型链实现对父类对象的方法继承</span></span><br><span class="line"><span class="comment">       2.利用Super（）借用父类型构建函数初始化相同属性       </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name=name;</span><br><span class="line">            <span class="built_in">this</span>.age=age;</span><br><span class="line">       &#125;</span><br><span class="line">       Person.prototype.setName=<span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.name=name;</span><br><span class="line">           <span class="built_in">this</span>.age=age;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,price</span>)</span>&#123;</span><br><span class="line">           Person.call(<span class="built_in">this</span>,name,age);<span class="comment">//相当于：this.Person（name，age） 为了得到父类型方法</span></span><br><span class="line">            <span class="comment">//  this是new出的s</span></span><br><span class="line">           <span class="built_in">this</span>.price=price;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//    继承</span></span><br><span class="line">       Student.prototype=<span class="keyword">new</span> Person();<span class="comment">//为了能看到父类型方法  子类型的原型指向父类型实例</span></span><br><span class="line">       Student.prototype.constructor=Student;<span class="comment">//修正constructor</span></span><br><span class="line">       Student.prototype.setPrice=<span class="function"><span class="keyword">function</span>(<span class="params">price</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.price=price;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> s=<span class="keyword">new</span> Student(<span class="string">&quot;Tom&quot;</span>,<span class="number">16</span>,<span class="number">1000000</span>);</span><br><span class="line">       s.setName(<span class="string">&#x27;haley&#x27;</span>);</span><br><span class="line">       s.setPrice(<span class="string">&#x27;1600000000&#x27;</span>)</span><br><span class="line">       <span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>

<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ul>
<li><p><strong>原型型链顶端</strong></p>
<p><strong>Object的原型对象所指向的原型对象为null</strong></p>
<p><strong><code>Object.prototype.__proto__===null  //true</code></strong></p>
</li>
<li><p><strong>构造函数与Function</strong>的关系</p>
<p><em>所有构造函数对象的隐式原型对象都指向<code>Function</code>的显示原型对象</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto===<span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Array</span>.__proto__===<span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.__proto__===<span class="built_in">Function</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.__proto__===<span class="built_in">Function</span>.prototype</span><br><span class="line">Person.prototype.__proto__===<span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure></li>
<li><p>Function与Object关系</p>
<ul>
<li><p><code>Object</code>为构造函数,所以有<code>Object.__proto===Function.prototype</code></p>
</li>
<li><p><code>Function</code>是对象</p>
<p><code>Function.prototype.__proto__===Object.prototype</code></p>
</li>
</ul>
</li>
<li><p>**构造函数与<code>Object</code>**的关系</p>
<p><em>所以构造函数的显示原型对象的隐式原型对象都指向Object的显式原型对象</em></p>
<p><em>只有Object的显示原型对象的隐式原型对象指向null</em></p>
</li>
<li><p><strong>构造函数实例与构造函数</strong>关系</p>
<p><em>构造函数实例的隐式原型对象指向构造函数的显示原型对象</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">obj=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">obj.__proto__===Person.prototype;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>**对象不一定是构造函数,所以通过构造函数创建的obj对象只有<code>__proto__</code>**属性</li>
<li><strong>构造函数,一定是对象,所以构造函数一般有prototype(显示原型)和<code>___proto__</code>隐式原型</strong></li>
</ul>
<ul>
<li><p>**显示原型对象(prototype)**是一个对象,不是构造函数,所以只有<code>__proto__</code>属性</p>
</li>
<li><p>任何一个函数都有<code>__proto__</code>和<code>prototype</code>属性,但是要想让该函数的原型对象可以被使用,就需要<code>new 函数()</code>则有<br><code>let obj=new Person(); obj.__proto__===Person.prototype</code></p>
</li>
<li><p><code>Array Object Function都可以看作 new Function()的结果</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Object</span>=<span class="keyword">new</span> <span class="built_in">Function</span>(); <span class="comment">//返回一个空函数给Object,此时Object的原型链断开了 不要这样做容易乱套</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__===<span class="built_in">Object</span>.prototype<span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>()<span class="comment">//返回一个空对象给obj</span></span><br></pre></td></tr></table></figure>

<p><strong>一般说原型对象是说prototype</strong></p>
</li>
<li><p>对象的<code>toString/valueof/hasOwnProperty等方法</code>都在<code>Object.prototype</code>对象里边</p>
</li>
<li><p><code>Object函数</code>对象自身上也有许多方法</p>
</li>
</ul>
<h3 id="函数的prototype"><a href="#函数的prototype" class="headerlink" title="函数的prototype"></a>函数的prototype</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1. 函数的prototype属性：</span></span><br><span class="line"><span class="comment">           每个函数都有一个prototype属性(引用对象属性)，它默认指向一个Object空对象（即原型对象）</span></span><br><span class="line"><span class="comment">           原型对象中有一个属性constructor，它指向函数对象</span></span><br><span class="line"><span class="comment">           构造函数的显示原型先产生，new出的该构造函数的实例的隐式原型后产生</span></span><br><span class="line"><span class="comment">       2.给原型对象添加属性（一般都是方法）</span></span><br><span class="line"><span class="comment">           作用：函数的所有对象自动拥有原型中的属性（方法）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           复习：</span></span><br><span class="line"><span class="comment">           1.执行函数定义：运行时，函数体没有执行，只是创建了函数对象，</span></span><br><span class="line"><span class="comment">   函数内部执行了语句this.prototype=&#123;&#125;  this为函数对象，向定义的这个函数中添加了属性，属性值为对象（即原型对象）</span></span><br><span class="line"><span class="comment">           执行函数：调用函数时，加（）</span></span><br><span class="line"><span class="comment">       2.实例对象：-函数（类型对象） 是Function，Object的实例</span></span><br><span class="line"><span class="comment">                   -new 构造函数产生的对象（隐式原型属性就是这时产生的）</span></span><br><span class="line"><span class="comment">               new 构造函数（） 内部 ：this.__proto__=构造函数名.prototype  this为创建的实例对象</span></span><br><span class="line"><span class="comment">       3.将一个引用变量赋值给另一个引用变量即可指向同一个对象</span></span><br><span class="line"><span class="comment">       4.原型链：-隐式原型属性，</span></span><br><span class="line"><span class="comment">               -原型链尽头是Object的隐式原型：null，不是Object， Object是函数</span></span><br><span class="line"><span class="comment">               -用于查找对象属性</span></span><br><span class="line"><span class="comment">       -构造函数实例对象的隐式原型指向构造函数的显式原型，构造函数的的隐式原型等于Function的显示原型</span></span><br><span class="line"><span class="comment">       Function：其隐式原型等于其显式原型</span></span><br><span class="line"><span class="comment">       -新给构造函数添加的显示原型属性不会影响到以前新建的实例对象的隐式原型属性，会影响到后来创建的实例对象的隐式原型属性</span></span><br><span class="line"><span class="comment">    --&gt;*/</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__); <span class="comment">//true</span></span><br><span class="line">   <span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">   fn.a = <span class="built_in">console</span>.log(<span class="string">&quot;dksjd&quot;</span>); <span class="comment">//相当于给fn加了个方法</span></span><br><span class="line"></span><br><span class="line">   fn(); <span class="comment">///dksjd</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;dklsd&quot;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">   fn1(); <span class="comment">//dklsd</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">   <span class="built_in">console</span>.log(obj.prototype); <span class="comment">//undefined</span></span><br><span class="line">   <span class="built_in">console</span>.log(obj.__proto__); <span class="comment">//object</span></span><br><span class="line">   <span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype, <span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype);</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(Fun.prototype); <span class="comment">//默认指向一个Object空对象（没有我们设置的属性）  &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype.constructor === <span class="built_in">Date</span>); <span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(Fun.prototype.constructor === Fun); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">   Fun.prototype.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;test()&quot;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">var</span> fun = <span class="keyword">new</span> Fun();</span><br><span class="line">   fun.test();</span><br></pre></td></tr></table></figure>

<h3 id="显-隐式原型对象"><a href="#显-隐式原型对象" class="headerlink" title="显/隐式原型对象"></a>显/隐式原型对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">      1.每个函数function都有一个prototype，即显式原型（属性）</span></span><br><span class="line"><span class="comment">      2.每个实例对象都有一个__proto__,可称为隐式原型（属性）</span></span><br><span class="line"><span class="comment">      3.对象的隐式原型的值为其对应构造函数的显式原型的值</span></span><br><span class="line"><span class="comment">      4.内存结构（图）</span></span><br><span class="line"><span class="comment">      5.总结：</span></span><br><span class="line"><span class="comment">          函数的prototype属性：在定义函数时自动添加，默认值为是一个空object对象</span></span><br><span class="line"><span class="comment">          对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值 undefined</span></span><br><span class="line"><span class="comment">          程序员能直接操作显式原型，但不能直接操作隐式原型</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="comment">//    定义构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//this.prototype=&#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(Fn.prototype);</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">new</span> Fn();</span><br><span class="line">    <span class="built_in">console</span>.log(fn._proto__); <span class="comment">//undefined 内部语句：this.__proto__=Fn.prototype</span></span><br><span class="line">    <span class="built_in">console</span>.log(Fn.prototype === fn.__proto__); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//给Fn原型对象（是个空对象）里边添加一个方法test</span></span><br><span class="line">    Fn.prototype.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//程序员能直接操作显式原型</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;hjsdd&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">   <span class="comment">// 通过实例调用原型方法;</span></span><br><span class="line">    fn.test();</span><br></pre></td></tr></table></figure>

<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">       原型链（图解）</span></span><br><span class="line"><span class="comment">       访问一个对象属性时，</span></span><br><span class="line"><span class="comment">           先在自身属性中查找，找到返回</span></span><br><span class="line"><span class="comment">           如果没有，再沿着__proto__这条链向上查找，找到返回</span></span><br><span class="line"><span class="comment">           如果最终没有找到，返回undefined</span></span><br><span class="line"><span class="comment">           原型链本质：隐式原型链，找对象属性</span></span><br><span class="line"><span class="comment">       别名：查找对象的属性（方法）</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       1.函数的显示原型：默认的空的Object实例对象</span></span><br><span class="line"><span class="comment">                       但是Object()显示原型不满足它</span></span><br><span class="line"><span class="comment">       2.Function是它自身的实例</span></span><br><span class="line"><span class="comment">           所有函数都是Function的实例（包括Function本身）</span></span><br><span class="line"><span class="comment">       3.Object的原型对象是原型链的尽头</span></span><br><span class="line"><span class="comment">         console.log(Object.prototype instanceof Object); //false</span></span><br><span class="line"><span class="comment">       instanceof的判断依据是查找原型链。 而 Object.prototype已经到原型链最顶层了， Object.prototype.__proto__ 值为null。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     <span class="comment">//    console.log(Object);</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype); <span class="comment">//默认为空的object对象</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">//null  object的原型对象的隐式原型</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">//Fn是Object的实例</span></span><br><span class="line">       <span class="built_in">this</span>.test1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&quot;test1()&quot;</span>);</span><br><span class="line">       &#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     Fn.prototype.test2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;test2()&quot;</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">var</span> fn = <span class="keyword">new</span> Fn();</span><br><span class="line">     <span class="built_in">console</span>.log(Fn.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//false</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">     fn.test1();</span><br><span class="line">     fn.test2();</span><br><span class="line">     <span class="built_in">console</span>.log(fn.toString());</span><br><span class="line">     <span class="comment">//    fn.test3();</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 所有函数都是Function的实例（包括Function本身）</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ == <span class="built_in">Function</span>.prototype); <span class="comment">//true</span></span><br><span class="line">     <span class="comment">// 3.Object的原型对象是原型链的尽头</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">//null</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>查找顺序</strong></p>
<blockquote>
<p>1.读取对象属性值时：会自动到原型链中查找</p>
<p> 2.设置对象属性时：不会查找原型链，如果对象中没有此属性，直接添加次属性并设置其值</p>
<p>3.方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</p>
</blockquote>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">        instanceof:判断左边对象是不是右边实例</span></span><br><span class="line"><span class="comment">        1.如何判断？</span></span><br><span class="line"><span class="comment">            表达式：A instanceof B</span></span><br><span class="line"><span class="comment">            如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false</span></span><br><span class="line"><span class="comment">            A找隐式原型，B找显示原型有交叉则返回true</span></span><br><span class="line"><span class="comment">            一般A为实例对象，B为构造函数</span></span><br><span class="line"><span class="comment">        2.Function是通过new自己产生实例的</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">       案例1</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line">      <span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Foo); <span class="comment">//true</span></span><br><span class="line">      <span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ == <span class="built_in">Function</span>.prototype); <span class="comment">//true</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ == <span class="built_in">Object</span>.prototype); <span class="comment">//false</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">      案例二</span></span><br><span class="line"><span class="comment">      实例对象隐式原型等于构造函数显式原型</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true Object可以既当构造函数又可以当构造函数实例</span></span><br><span class="line">      <span class="comment">//  所有函数原型对象默认都是Object实例，Object除外</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> Foo); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><strong>练习</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第1题</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">     A.prototype.n = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line">     A.prototype = &#123;</span><br><span class="line">       n: <span class="number">2</span>,</span><br><span class="line">       m: <span class="number">3</span>,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">var</span> c = <span class="keyword">new</span> A();</span><br><span class="line">     <span class="built_in">console</span>.log(b.n, b.m, c.n, c.m); <span class="comment">//1 undefined  2 3</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* </span></span><br><span class="line"><span class="comment">       第二题</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">     <span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;a()&quot;</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&quot;b()&quot;</span>);</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">     f.a(); <span class="comment">//a（）  fn.__proto___===F.prototype ;但是没有b,F.prototype.__proto__===Object.prototype,还是没有b只有a</span></span><br><span class="line">     <span class="comment">// f.b();//f的隐式原型链找不到Function的隐式原型链</span></span><br><span class="line">     F.a(); <span class="comment">//a（） F.prototype.__proto__===Object.prototype 可以找到a</span></span><br><span class="line">     F.b(); <span class="comment">//b()//F.__proto__===Function.prototype 可以找到b</span></span><br><span class="line">     <span class="built_in">console</span>.log(f);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);</span><br></pre></td></tr></table></figure>

<h2 id="浅析闭包"><a href="#浅析闭包" class="headerlink" title="浅析闭包"></a>浅析闭包</h2><p><strong>闭包理解</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.如何产生闭包？</span></span><br><span class="line"><span class="comment">            当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量函数时，就产生了闭包</span></span><br><span class="line"><span class="comment">        2.闭包到底是什么？</span></span><br><span class="line"><span class="comment">            使用Chrome查看</span></span><br><span class="line"><span class="comment">            理解一：闭包是嵌套的内部函数（绝大部分人）</span></span><br><span class="line"><span class="comment">            理解二：包含被引用变量（函数）的内部函数（变量）  保存着引用变量的内部函数</span></span><br><span class="line"><span class="comment">            注意：闭包存在于嵌套内部函数中</span></span><br><span class="line"><span class="comment">        3.产生闭包的条件？ </span></span><br><span class="line"><span class="comment">            函数嵌套</span></span><br><span class="line"><span class="comment">            内部函数引用了外部函数数据（变量/函数）*/</span></span><br><span class="line">         <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> c=<span class="string">&quot;kdlfjk&quot;</span></span><br><span class="line">                    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;<span class="comment">//执行函数定义就会产生闭包，fn1内部得调用fn2</span></span><br><span class="line">                        <span class="built_in">console</span>.log(c)</span><br><span class="line">                    &#125;</span><br><span class="line">                    fn2();</span><br><span class="line">                &#125;</span><br><span class="line">                fn1();</span><br></pre></td></tr></table></figure>

<p><strong>常见闭包</strong></p>
<blockquote>
<p>1.将函数作为另一个函数返回值 最外部的函数调用几次，闭包就创建几次</p>
<p>2.将函数作为实参传递给另一个调用 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1.将函数作为另一个函数返回值 </span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   a++;</span><br><span class="line">                   <span class="built_in">console</span>.log(a);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fn2;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">var</span> f=fn1();<span class="comment">//闭包创建1次</span></span><br><span class="line">        f()<span class="comment">//3</span></span><br><span class="line">        f()<span class="comment">//4</span></span><br><span class="line">            fn1()<span class="comment">//闭包创建2次</span></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">           <span class="comment">//  2.将函数作为实参传递给另一个调用</span></span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">showDelay</span>(<span class="params">msg,time</span>)</span>&#123;</span><br><span class="line">               <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   alert(msg)<span class="comment">//内部函数引用了msg，所以有闭包</span></span><br><span class="line">               &#125;,time)<span class="comment">//time的引用不在内部函数里，不算闭包</span></span><br><span class="line">           &#125;</span><br><span class="line">           showDelay(<span class="string">&#x27;dfjdlk&#x27;</span>,<span class="number">200</span>)<span class="comment">//闭包调用一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>闭包作用</strong></p>
<blockquote>
<p>​    1.使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）</p>
<p>​      2.让外部函数可以操作（读写）到内部的数据（变量/函数）</p>
<p>​      问题：</p>
<p>​        1.函数执行完后，函数内部声明的局部变量是否还存在？一般不存在，存在于闭包中的变量才可能存在</p>
<p>​        2.在函数外部可以直接访问函数内部的局部变量吗？不能，但我们可以通过闭包让外部操作它</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">//此时闭包就已经产生了（函数提升，内部函数对象已经创建了）</span></span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          a--;</span><br><span class="line">          <span class="built_in">console</span>.log(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          a--;</span><br><span class="line">          <span class="built_in">console</span>.log(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn3;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> f = fn1(); <span class="comment">//函数执行完只有a在闭包里，fn3和fn2变量都被自由释放了，但函数对象没有当成垃圾对象</span></span><br><span class="line">      <span class="comment">//  f指向函数对象，闭包使得函数对象没有被释放根本原因是f导致的，（也是因为有return fn3）fn3变量本身不在了，而是外部变量f引用了fn3地址，f此时指向函数对象</span></span><br><span class="line">      f(); <span class="comment">//1</span></span><br><span class="line">      f(); <span class="comment">//0</span></span><br><span class="line">f=<span class="literal">null</span>;<span class="comment">//闭包死亡（包含闭包的函数对象成为垃圾对象）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>闭包生命周期</strong></p>
<ul>
<li>闭包产生：在 嵌套内部函数定义 执行完成时产生（不是在调用）</li>
<li>死亡：在嵌套内部函数成为垃圾对象时</li>
</ul>
<p><strong>应用</strong></p>
<blockquote>
<p>闭包应用：</p>
<ul>
<li><p>定义<code>js</code>模块</p>
<ul>
<li>具有特定功能的js文件</li>
<li> 将所有数据和功能都封装在一个函数内部（私有的）</li>
<li>只向外暴露一个包含n个方法的对象或函数</li>
<li>模块的使用者，只需要通过模块暴露对象调用方法来实现对应功能 </li>
</ul>
</li>
<li><p>对象不私有函数才私有</p>
</li>
</ul>
<ul>
<li>想暴露两个函数，就封装对象后返回</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">var</span> msg=<span class="string">&#x27;shjkd&#x27;</span>;</span><br><span class="line">    <span class="comment">// 操作数据的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething()&#x27;</span>+msg.toUpperCase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing()&#x27;</span>+msg.toLowerCase);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 向外暴露一个对象</span></span><br><span class="line">    <span class="comment">// return doOtherthing;</span></span><br><span class="line">    <span class="comment">// 向外暴露2个对象 给外部使用的方法</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething:doSomething,</span><br><span class="line">        doOtherthing:doOtherthing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"><span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">var</span> msg=<span class="string">&#x27;shjkd&#x27;</span>;</span><br><span class="line">    <span class="comment">// 操作数据的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;doSomething()&#x27;</span>+msg.toUpperCase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doOtherthing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;doOtherthing()&#x27;</span>+msg.toLowerCase);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">     <span class="built_in">window</span>.myModule2= &#123;</span><br><span class="line">        doSomething:doSomething,</span><br><span class="line">        doOtherthing:doOtherthing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./myModule.js&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./myModule2.js&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> &gt;</span></span><br><span class="line">    myModule2.doOtherthing();</span><br><span class="line">    myModule2.doSomething();</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> <span class="built_in">module</span>=myModule();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">module</span>.doOtherthing();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">module</span>.doSomething();  </span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>闭包缺点</strong></p>
<blockquote>
<p> 缺点：</p>
<ul>
<li>函数执行完后，函数内的局部变量没有释放，占用内存时间会变长</li>
<li>容易造成内存泄漏</li>
</ul>
<p>2.解决：</p>
<ul>
<li>能不用闭包就不用</li>
<li>及时释放 </li>
</ul>
<p>3.内存溢出：</p>
<p>​      一种程序运行时出现的错误</p>
<p>​      当程序运行需要的内存超过了剩余的内存时，就出现内存溢出的错误</p>
<p>4.内存泄漏： </p>
<ul>
<li>一次泄漏还能正常运行</li>
<li>占用内存没有及时释放</li>
<li> 内存泄漏积累多了就容易导致内存溢出</li>
</ul>
<ul>
<li>常见内存泄漏：<ul>
<li>意外全局变量</li>
<li>没有及时清理计时器或回调函数</li>
<li>闭包</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 内存溢出</span></span><br><span class="line">       <span class="keyword">var</span> obj=&#123;&#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">          obj[i]=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 此时obj为伪数组</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 意外全局变量</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           a=<span class="number">3</span></span><br><span class="line">           <span class="built_in">console</span>.log(a);</span><br><span class="line">       &#125; </span><br><span class="line">       fn()<span class="comment">//a is not released</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有及时清理计时器或回调函数</span></span><br><span class="line">      <span class="keyword">var</span> timer=<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;-------&#x27;</span>);</span><br><span class="line">       &#125;,<span class="number">1000</span>)</span><br><span class="line">       <span class="comment">// clearInterval(timer);</span></span><br><span class="line">      </span><br><span class="line">       <span class="comment">//     闭包</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> a=<span class="number">4</span>;</span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(++a);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> fn2;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> f=fn1();</span><br><span class="line">       f();</span><br><span class="line">       <span class="comment">// f=null  不执行此操作a不会被释放</span></span><br></pre></td></tr></table></figure>

<p><strong>练习</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> <span class="built_in">Object</span> = &#123;</span><br><span class="line">        name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">        getNameFun: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">//无闭包</span></span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//bject.getNameFun()相当返回了函数本身,再次加()调用时,是window在调用</span></span><br><span class="line">      alert(<span class="built_in">Object</span>.getNameFun()()); <span class="comment">// The Window   this代表的是window</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 代码片段二</span></span><br><span class="line">      <span class="keyword">var</span> name2 = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> Object1 = &#123;</span><br><span class="line">        name2: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">        getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">//有闭包</span></span><br><span class="line">          <span class="keyword">var</span> that = <span class="built_in">this</span>; <span class="comment">//that等于Object</span></span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name2; <span class="comment">//that等于Object</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">      alert(Object1.getNameFunc()()); <span class="comment">// My Object</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line">     <span class="keyword">var</span> <span class="built_in">Object</span> = &#123;</span><br><span class="line">       name: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">       getNameFun: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="comment">//无闭包</span></span><br><span class="line">         <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">         &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="comment">//bject.getNameFun()相当返回了函数本身,再次加()调用时,是window在调用</span></span><br><span class="line">     alert(<span class="built_in">Object</span>.getNameFun()()); <span class="comment">// The Window   this代表的是window</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 代码片段二</span></span><br><span class="line">     <span class="keyword">var</span> name2 = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line">     <span class="keyword">var</span> Object1 = &#123;</span><br><span class="line">       name2: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">       getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="comment">//有闭包</span></span><br><span class="line">         <span class="keyword">var</span> that = <span class="built_in">this</span>; <span class="comment">//that等于Object</span></span><br><span class="line">         <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> that.name2; <span class="comment">//that等于Object</span></span><br><span class="line">         &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;;</span><br><span class="line">     alert(Object1.getNameFunc()()); <span class="comment">// My Object</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 代码片段3</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n, o</span>) </span>&#123;</span><br><span class="line">       <span class="comment">//有闭包n 闭包在对象内部</span></span><br><span class="line">       <span class="built_in">console</span>.log(o);</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         fun: <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> fun(m, n);</span><br><span class="line">         &#125;,</span><br><span class="line">       &#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> a = fun(<span class="number">0</span>); <span class="comment">//调用完后返回对象，对象里在调用fun</span></span><br><span class="line">     <span class="built_in">console</span>.log(a); <span class="comment">//a是对象   &#123;fun:function(m)&#123;return fun(m,n);&#125;</span></span><br><span class="line">     a.fun(<span class="number">1</span>); <span class="comment">// fun（m，n）  fun（1，0） 此时fun调用的是里面的fun 所以是0，调用a.fun（1，0）下一次执行到停在return&#123;&#125;前，所以执行了外部fun又产生新的闭包</span></span><br><span class="line">     <span class="comment">//  如果是 var xxx=a.fun（1），则xxx里边有闭包，且闭包值为1，即此时n为1，但是现在没有xxx接收，所以无论传什么，都用a的闭包n为0</span></span><br><span class="line">     <span class="built_in">console</span>.log(a);</span><br><span class="line">     a.fun(<span class="number">2</span>);</span><br><span class="line">     a.fun(<span class="number">3</span>); <span class="comment">//undefined  0 0 0</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>); <span class="comment">//undefined  0   1  2 3     0后产生了新的闭包 相当于fun（0）.fun(1).  此时新的闭包n是1，所以输出1  之后调.fun（2）又产生新的闭包，n=2</span></span><br><span class="line">     <span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>); <span class="comment">// undefined  0</span></span><br><span class="line">     c.fun(<span class="number">2</span>); <span class="comment">//1</span></span><br><span class="line">     c.fun(<span class="number">3</span>); <span class="comment">//1    50 51行c都是 &#123;fun:function(m)&#123;return fun(m,1);&#125;&#125;; 传入的2，3是m</span></span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/21/JS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0(%E4%B8%8A)/" rel="next" title="JS基础学习(上)">
                <i class="fa fa-chevron-left"></i> JS基础学习(上)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">事件对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">常见的事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87-%E9%94%AE%E7%9B%98%E5%B1%9E%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">鼠标&#x2F;键盘属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">事件的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%86%92%E6%B3%A1"><span class="nav-number">1.5.</span> <span class="nav-text">事件的冒泡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%B4%BE"><span class="nav-number">1.6.</span> <span class="nav-text">事件委派</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="nav-number">1.7.</span> <span class="nav-text">事件绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="nav-number">1.8.</span> <span class="nav-text">事件的传播</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BOM"><span class="nav-number">2.</span> <span class="nav-text">BOM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BOM%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.</span> <span class="nav-text">BOM对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#navigator"><span class="nav-number">2.2.</span> <span class="nav-text">navigator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#history"><span class="nav-number">2.3.</span> <span class="nav-text">history</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#location"><span class="nav-number">2.4.</span> <span class="nav-text">location</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">2.5.</span> <span class="nav-text">定时器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSON"><span class="nav-number">3.</span> <span class="nav-text">JSON</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">3.0.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96JSON%E7%9F%A5%E8%AF%86"><span class="nav-number">3.0.2.</span> <span class="nav-text">其他JSON知识</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7JS"><span class="nav-number">4.</span> <span class="nav-text">高级JS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">4.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE"><span class="nav-number">4.1.1.</span> <span class="nav-text">数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE-%E5%8F%98%E9%87%8F-%E5%86%85%E5%AD%98"><span class="nav-number">4.1.2.</span> <span class="nav-text">数据,变量,内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.3.</span> <span class="nav-text">函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.2.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.3.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84prototype"><span class="nav-number">4.4.1.</span> <span class="nav-text">函数的prototype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE-%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.4.2.</span> <span class="nav-text">显&#x2F;隐式原型对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">4.4.3.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof"><span class="nav-number">4.4.4.</span> <span class="nav-text">instanceof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E6%9E%90%E9%97%AD%E5%8C%85"><span class="nav-number">4.5.</span> <span class="nav-text">浅析闭包</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">haley06</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
